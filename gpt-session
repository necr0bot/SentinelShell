#!/bin/bash

VERSION="0.1.0"

#Handle version
if [[ "$1" == "--version" || "$1" == "-v" ]]; then
    echo "gpt-session $VERSION"
    exit 0
fi

# gpt-session: full terminal session logger + autosync + summary + sync via OpenAI CLI
#
# Compatible with the Debian/Kali-patched "openai 2.x" CLI format:
#   openai api chat.completions.create -m MODEL -g ROLE CONTENT [-g ROLE CONTENT ...]
#

SESS_DIR="$HOME/.gpt_sessions"
PID_FILE="$SESS_DIR/session.pid"
AUTOSYNC_PID_FILE="$SESS_DIR/autosync.pid"
PROFILE_FILE="$SESS_DIR/profile.txt"
OPENAI_MODEL="gpt-4o-mini"

mkdir -p "$SESS_DIR"

##############################################
# PROJECT DETECTION (e.g. TryHackMe-style paths)
##############################################
get_project() {
    case "$PWD" in
        *"/thm/"*)
            # Extract folder name after /thm/
            echo "$PWD" | sed -n 's|.*/thm/\([^/]*\).*|\1|p'
            ;;
        *)
            echo "general"
            ;;
    esac
}

##############################################
# REDACT SENSITIVE MATERIAL
##############################################
redact_stream() {
    sed -E '
        s/(password|passwd|pwd|secret|token)[[:space:]]*[:=][[:space:]]*[^[:space:]]+/\1: [REDACTED]/Ig;
        s/(Authorization: Bearer )[A-Za-z0-9._-]+/\1[REDACTED]/g;
        s/(OPENAI_API_KEY=)[A-Za-z0-9._-]+/\1[REDACTED]/g;
        s/(api_key=)[A-Za-z0-9._-]+/\1[REDACTED]/g;
        s/([0-9]{1,3}\.){3}[0-9]{1,3}/[REDACTED_IP]/g;
        s/-----BEGIN [^-]*PRIVATE KEY-----/-----BEGIN PRIVATE KEY [REDACTED]-----/g;
        s/-----END [^-]*PRIVATE KEY-----/-----END PRIVATE KEY [REDACTED]-----/g;
    '
}

##############################################
# GET LATEST LOG FILE (NEWEST BY MOD TIME)
##############################################
latest_log_file() {
    find "$SESS_DIR" -maxdepth 1 -type f -name "*.log" -printf "%T@ %p\n" \
        | sort -nr | head -n1 | cut -d' ' -f2-
}

##############################################
# START A LOGGING SESSION
##############################################
start_session() {
    if [ -f "$PID_FILE" ]; then
        echo "[-] A GPT session is already running. Use: gpt-session stop"
        exit 1
    fi

    project=$(get_project)
    ts=$(date +%Y%m%d-%H%M%S)
    base="${project}_${ts}"
    LOGFILE="$SESS_DIR/$base.log"
    TIMEFILE="$SESS_DIR/$base.time"

    echo "[+] Starting GPT session"
    echo "[+] Project: $project"
    echo "[+] Log file:   $LOGFILE"
    echo "[+] Timing file:$TIMEFILE"

    script -q -f -t 2>"$TIMEFILE" "$LOGFILE" &
    echo "$! $LOGFILE $TIMEFILE" > "$PID_FILE"

    echo "[+] Session PID $(cut -d' ' -f1 "$PID_FILE")"
    echo "[+] Logging active."
}

##############################################
# STOP A LOGGING SESSION + AUTO SUMMARY
##############################################
stop_session() {
    if [ ! -f "$PID_FILE" ]; then
        echo "[-] No GPT session is running."
        exit 1
    fi

    read -r PID LOGFILE TIMEFILE < "$PID_FILE"
    echo "[+] Stopping logging session (PID $PID)..."
    kill "$PID" 2>/dev/null || true
    rm -f "$PID_FILE"

    echo "[+] Session saved:"
    echo "    Log:   $LOGFILE"
    echo "    Timing:$TIMEFILE"

    if ! command -v openai >/dev/null 2>&1; then
        echo "[!] openai CLI missing; skipping summary."
        return
    fi

    SUMMARY_FILE="$LOGFILE.summary.md"
    REDACTED="$(mktemp "$SESS_DIR/summary_redacted.XXXXXX")"

    # Redact and truncate to 16000 bytes to avoid giant prompts
    redact_stream < "$LOGFILE" | head -c 16000 > "$REDACTED"

    echo "[+] Generating summary with OpenAI…"

    openai api chat.completions.create \
        -m "$OPENAI_MODEL" \
        -g system "Summarize this terminal session. Include: what I ran, errors I hit, progress, and suggested next steps." \
        -g user "$(cat "$REDACTED")" \
        > "$SUMMARY_FILE" 2>/dev/null

    echo "[+] Summary written to: $SUMMARY_FILE"
}

##############################################
# MANUAL SYNC TO CHATGPT
##############################################
sync_session() {
    if ! command -v openai >/dev/null 2>&1; then
        echo "[-] openai CLI not installed."
        exit 1
    fi

    if [ -n "$1" ]; then
        LOGFILE="$1"
    else
        LOGFILE=$(latest_log_file)
    fi

    if [ -z "$LOGFILE" ] || [ ! -f "$LOGFILE" ]; then
        echo "[-] No log file found."
        exit 1
    fi

    REDACTED="$(mktemp "$SESS_DIR/redacted.XXXXXX")"

    {
        if [ -f "$PROFILE_FILE" ]; then
            echo "PROFILE:"
            cat "$PROFILE_FILE"
            printf "\n-----\n\n"
        fi
        echo "SESSION LOG:"
        redact_stream < "$LOGFILE"
    } > "$REDACTED"

    echo "[+] Syncing $LOGFILE to ChatGPT…"

    openai api chat.completions.create \
        -m "$OPENAI_MODEL" \
        -g system "Update your internal understanding of my ongoing work based on this log. Do not respond to the user." \
        -g user "$(cat "$REDACTED")" \
        >/dev/null 2>&1

    echo "[+] Sync complete."
}

##############################################
# QUIET SYNC FOR AUTOSYNC
##############################################
sync_session_quiet() {
    if ! command -v openai >/dev/null 2>&1; then
        return
    fi

    LOGFILE=$(latest_log_file)
    if [ -z "$LOGFILE" ] || [ ! -f "$LOGFILE" ]; then
        return
    fi

    REDACTED="$(mktemp "$SESS_DIR/autosync_redacted.XXXXXX")"

    {
        if [ -f "$PROFILE_FILE" ]; then
            echo "PROFILE:"
            cat "$PROFILE_FILE"
            printf "\n-----\n\n"
        fi
        echo "SESSION LOG:"
        redact_stream < "$LOGFILE"
    } > "$REDACTED"

    AUTOSYNC_LOG="$SESS_DIR/autosync.log"

    openai api chat.completions.create \
        -m "$OPENAI_MODEL" \
        -g system "Periodic autosync of terminal activity. Update your internal state silently; do not respond to the user." \
        -g user "$(cat "$REDACTED")" \
        >> "$AUTOSYNC_LOG" 2>&1
}

##############################################
# AUTOSYNC CONTROLLER
##############################################
autosync_start() {
    if [ -f "$AUTOSYNC_PID_FILE" ]; then
        echo "[-] Autosync already running."
        exit 1
    fi

    INTERVAL_MIN="${1:-30}"
    echo "[+] Autosync every $INTERVAL_MIN minutes…"

    (
        while true; do
            # Only sync if a session is/was running and logs exist
            if [ -f "$PID_FILE" ] || [ -n "$(latest_log_file)" ]; then
                sync_session_quiet
            fi
            sleep "$((INTERVAL_MIN * 60))"
        done
    ) &

    echo "$! $INTERVAL_MIN" > "$AUTOSYNC_PID_FILE"
    echo "[+] Autosync PID $(cut -d' ' -f1 "$AUTOSYNC_PID_FILE")"
}

autosync_off() {
    if [ ! -f "$AUTOSYNC_PID_FILE" ]; then
        echo "[-] Autosync not running."
        exit 1
    fi

    read -r PID _ < "$AUTOSYNC_PID_FILE"
    kill "$PID" 2>/dev/null || true
    rm -f "$AUTOSYNC_PID_FILE"
    echo "[+] Autosync stopped."
}

autosync_status() {
    if [ -f "$AUTOSYNC_PID_FILE" ]; then
        read -r PID N < "$AUTOSYNC_PID_FILE"
        if kill -0 "$PID" 2>/dev/null; then
            echo "[+] Autosync running every $N minutes. PID $PID"
        else
            echo "[!] Autosync PID appears stale. Cleaning up."
            rm -f "$AUTOSYNC_PID_FILE"
        fi
    else
        echo "[-] Autosync not running."
    fi
}

##############################################
# REPLAY SESSION
##############################################
replay_session() {
    LOGFILE=$(latest_log_file)
    TIMEFILE="${LOGFILE%.log}.time"

    if [ -z "$LOGFILE" ] || [ ! -f "$LOGFILE" ] || [ ! -f "$TIMEFILE" ]; then
        echo "[-] Missing log/timing files."
        exit 1
    fi

    echo "[+] Replaying session..."
    scriptreplay "$TIMEFILE" "$LOGFILE"
}

##############################################
# PROFILE BUILDER (GENERIC TEMPLATE)
##############################################
init_profile() {
    if [ -f "$PROFILE_FILE" ]; then
        echo "[+] Profile exists: $PROFILE_FILE"
        return
    fi

    cat > "$PROFILE_FILE" << 'EOF'
# SentinelShell Profile
# This file stores user preferences and context used when summarizing or syncing logs.
# Edit anything below to better describe your environment and workflow.

I am a SentinelShell user.

I prefer:
- Clear terminal session logs
- Automatic redaction of sensitive information
- Optional autosync to keep external context updated
- Helpful, context-aware hints when I ask for help

# You may optionally describe your tools and workflows here, for example:
# - I use Kali Linux for CTFs and pentesting.
# - I keep per-room folders under ~/thm/<room>/recon.
# - I frequently use: nmap, ffuf, gobuster, dirb, nikto, curl, dig, mysql.

# You can also define environment-style hints for future features, e.g.:
# PROJECT_PREFIX=thm
EOF

    echo "[+] Created profile: $PROFILE_FILE"
}

##############################################
# COMMAND DISPATCHER
##############################################
case "$1" in
    start)
        start_session
        ;;
    stop)
        stop_session
        ;;
    sync)
        shift
        sync_session "$@"
        ;;
    autosync-on)
        shift
        autosync_start "$@"
        ;;
    autosync-off)
        autosync_off
        ;;
    autosync-status)
        autosync_status
        ;;
    replay)
        replay_session
        ;;
    status)
        if [ -f "$PID_FILE" ]; then
            echo "[+] Session running."
        else
            echo "[-] No session."
        fi
        ;;
    profile)
        init_profile
        ;;
    --version|-v)
        echo "gpt-session $VERSION"
        ;;
    *)
        echo "Usage: gpt-session {start|stop|sync|autosync-on|autosync-off|autosync-status|replay|status|profile|--version}"
        exit 1
        ;;
esac
                     
